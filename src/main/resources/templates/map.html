<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://kit.fontawesome.com/7e5c972fe1.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <title>Mapa</title>
    <style>
        #map {
            height: 100vh;
            width: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .icon-large-truck {
            font-size: 25px;
            color: black;
        }

        .icon-large-driver {
            font-size: 25px;
            color: blue;
        }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = L.map('map').setView([52, 20], 7);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    const handleError = (error, type) => {
        console.error(`Błąd podczas pobierania danych dla ${type}:`, error);
        alert(`Nie udało się załadować danych dla ${type}.`);
    };

    const driverIcon = L.divIcon({
        className: 'icon-large-driver',
        iconSize: [50, 50],
        iconAnchor: [10, 20],
        popupAnchor: [0, -32],
        html: '<i class="fa-solid fa-location-dot"></i>'
    });

    const truckIcon = L.divIcon({
        className: 'icon-large-truck',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32],
        html: '<i class="fa-solid fa-location-dot"></i>'
    });

    fetch('/location/drivers')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(drivers => {
            drivers.forEach(driver => {
                L.marker([driver.coordinates.x, driver.coordinates.y], {icon: driverIcon})
                    .addTo(map)
                    .bindPopup(`Kierowca: ${driver.name}; ID: ${driver.id}`);
            });
        })
        .catch(error => handleError(error, "kierowców"));

    fetch('/location/trucks')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(trucks => {
            trucks.forEach(truck => {
                L.marker([truck.coordinates.x, truck.coordinates.y], {icon: truckIcon})
                    .addTo(map)
                    .bindPopup(`Pojazd: ${truck.licensePlate}; ID: ${truck.id}`);
            });
        })
        .catch(error => handleError(error, "pojazdów"));



async function geocodeCity(city) {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}`);
    const data = await response.json();
    if (data.length > 0) {
        return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    } else {
        throw new Error(`Nie znaleziono współrzędnych dla miasta: ${city}`);
    }
}

async function geocodeCities(cities) {
    const coordinates = [];
    for (const city of cities) {
        try {
            const coords = await geocodeCity(city);
            coordinates.push(coords);
        } catch (error) {
            console.error(error);
        }
    }
    return coordinates;
}

async function getRouteFromOSRM(startCoords, endCoords) {
    const routeUrl = `https://router.project-osrm.org/route/v1/driving/${startCoords[1]},${startCoords[0]};${endCoords[1]},${endCoords[0]}?overview=full&geometries=geojson`;

    const response = await fetch(routeUrl);
    if (!response.ok) {
        throw new Error(`Błąd podczas pobierania trasy: ${response.status}`);
    }

    const data = await response.json();
    if (data.routes && data.routes[0] && data.routes[0].geometry) {
        const distance = data.routes[0].distance;
        const routeCoordinates = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
        return { routeCoordinates, distance };
    } else {
        throw new Error('Brak dostępnych danych o trasie');
    }
}
async function updateRoadDistance(roadId, distance) {
    const url = `/location/road/distance/${roadId}`;
    const price = parseFloat((distance * 7).toFixed(2));


    console.log(`Wysyłanie żądania PATCH do: ${url} z dystansem: ${distance} i ceną: ${price}`);

    try {
        const response = await fetch(`${url}?distance=${distance}&price=${price}`, {
            method: 'PATCH',
        });

        if (!response.ok) {
            throw new Error(`Błąd podczas aktualizacji dystansu: ${response.status}`);
        }

        console.log("Dystans został zaktualizowany w bazie danych.");
    } catch (error) {
        console.error(`Błąd: ${error.message}`);
    }
}




fetch('/location/roads')
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
    })
    .then(async roads => {
        const routeColors = ['blue', 'green', 'red', 'purple'];

        for (let routeCount = 0; routeCount < roads.length; routeCount++) {
            const road = roads[routeCount];
            const cities = [road.from, ...road.via, road.to];
            const start = road.departureDate;
            const end = road.arrivalDate;
            const roadId = road.id;

            const coordinates = await geocodeCities(cities);

            try {
                let totalDistance = 0;
                let allCoordinates = [];

                for (let i = 0; i < coordinates.length - 1; i++) {
                    const startCoords = coordinates[i];
                    const endCoords = coordinates[i + 1];

                    const { routeCoordinates, distance } = await getRouteFromOSRM(startCoords, endCoords);

                    allCoordinates = [...allCoordinates, ...routeCoordinates];
                    totalDistance += distance;
                }

                const totalDistanceInKm = (totalDistance / 1000).toFixed(2);
                const cost = (totalDistanceInKm * 7).toFixed(2);

                const routeColor = routeColors[routeCount % routeColors.length];
                const polyline = L.polyline(allCoordinates, { color: routeColor, weight: 4, opacity: 0.7 })
                    .addTo(map);

                polyline.bindPopup(`
                    <strong>RoadID:</strong> ${roadId}<br>
                    <strong>Trasa:</strong> ${cities.join(' -> ')}<br>
                    <strong>Start:</strong> ${start}<br>
                    <strong>Koniec:</strong> ${end}<br>
                    <strong>Długość całkowita:</strong> ${totalDistanceInKm} km<br>
                    <strong>Koszt:</strong> ${cost} zł <br>
                    <strong>DriverID:</strong> ${road.driverId}<br>
                    <strong>TruckID:</strong> ${road.truckId}
                `);

            await updateRoadDistance(roadId, totalDistanceInKm);

            } catch (error) {
                console.error(`Błąd przy rysowaniu trasy: ${error.message}`);
            }
        }
    })
    .catch(error => console.error(`Błąd przy ładowaniu danych o trasach: ${error.message}`));

</script>
</body>
</html>
